        -:    0:Source:/usr/local/include/xercesc/util/XMLString.hpp
        -:    0:Graph:game_entity_factory.gcno
        -:    0:Data:game_entity_factory.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Licensed to the Apache Software Foundation (ASF) under one or more
        -:    3: * contributor license agreements.  See the NOTICE file distributed with
        -:    4: * this work for additional information regarding copyright ownership.
        -:    5: * The ASF licenses this file to You under the Apache License, Version 2.0
        -:    6: * (the "License"); you may not use this file except in compliance with
        -:    7: * the License.  You may obtain a copy of the License at
        -:    8: *
        -:    9: *      http://www.apache.org/licenses/LICENSE-2.0
        -:   10: *
        -:   11: * Unless required by applicable law or agreed to in writing, software
        -:   12: * distributed under the License is distributed on an "AS IS" BASIS,
        -:   13: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   14: * See the License for the specific language governing permissions and
        -:   15: * limitations under the License.
        -:   16: */
        -:   17:
        -:   18:/*
        -:   19: * $Id: XMLString.hpp 932887 2010-04-11 13:04:59Z borisk $
        -:   20: */
        -:   21:
        -:   22:#if !defined(XERCESC_INCLUDE_GUARD_XMLSTRING_HPP)
        -:   23:#define XERCESC_INCLUDE_GUARD_XMLSTRING_HPP
        -:   24:
        -:   25:#include <xercesc/util/BaseRefVectorOf.hpp>
        -:   26:#include <xercesc/framework/XMLBuffer.hpp>
        -:   27:#include <xercesc/framework/MemoryManager.hpp>
        -:   28:#include <string.h>
        -:   29:#include <assert.h>
        -:   30:
        -:   31:XERCES_CPP_NAMESPACE_BEGIN
        -:   32:
        -:   33:class XMLLCPTranscoder;
        -:   34:/**
        -:   35:  * Class for representing native character strings and handling common string
        -:   36:  * operations
        -:   37:  *
        -:   38:  * This class is Unicode compliant. This class is designed primarily
        -:   39:  * for internal use, but due to popular demand, it is being made
        -:   40:  * publicly available. Users of this class must understand that this
        -:   41:  * is not an officially supported class. All public methods of this
        -:   42:  * class are <i>static functions</i>.
        -:   43:  *
        -:   44:  */
        -:   45:class XMLUTIL_EXPORT XMLString
        -:   46:{
        -:   47:public:
        -:   48:    /* Static methods for native character mode string manipulation */
        -:   49:
        -:   50:
        -:   51:    /** @name String concatenation functions */
        -:   52:    //@{
        -:   53:    /** Concatenates two strings.
        -:   54:      *
        -:   55:      * <code>catString</code> appends <code>src</code> to <code>target</code> and
        -:   56:      * terminates the resulting string with a null character. The initial character
        -:   57:      * of <code>src</code> overwrites the terminating character of <code>target
        -:   58:      * </code>.
        -:   59:      *
        -:   60:      * No overflow checking is performed when strings are copied or appended.
        -:   61:      * The behavior of <code>catString</code> is undefined if source and
        -:   62:      * destination strings overlap.
        -:   63:      *
        -:   64:      * @param target Null-terminated destination string
        -:   65:      * @param src Null-terminated source string
        -:   66:      */
        -:   67:    static void catString
        -:   68:    (
        -:   69:                char* const     target
        -:   70:        , const char* const     src
        -:   71:    );
        -:   72:
        -:   73:    /** Concatenates two strings.
        -:   74:      *
        -:   75:      * <code>catString</code> appends <code>src</code> to <code>target</code> and
        -:   76:      * terminates the resulting string with a null character. The initial character of
        -:   77:      * <code>src</code> overwrites the terminating character of <code>target</code>.
        -:   78:      * No overflow checking is performed when strings are copied or appended.
        -:   79:      * The behavior of <code>catString</code> is undefined if source and destination
        -:   80:      * strings overlap.
        -:   81:      *
        -:   82:      * @param target Null-terminated destination string
        -:   83:      * @param src Null-terminated source string
        -:   84:      */
        -:   85:    static void catString
        -:   86:    (
        -:   87:                XMLCh* const    target
        -:   88:        , const XMLCh* const    src
        -:   89:    );
        -:   90:    //@}
        -:   91:
        -:   92:    /** @name String comparison functions */
        -:   93:    //@{
        -:   94:    /** Lexicographically compares lowercase versions of <code>str1</code> and
        -:   95:      * <code>str2</code> and returns a value indicating their relationship.
        -:   96:      * @param str1 Null-terminated string to compare
        -:   97:      * @param str2 Null-terminated string to compare
        -:   98:      *
        -:   99:      * @return The return value indicates the relation of <code>str1</code> to
        -:  100:      * <code>str2</code> as follows
        -:  101:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  102:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  103:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  104:      */
        -:  105:    static int compareIString
        -:  106:    (
        -:  107:        const   char* const     str1
        -:  108:        , const char* const     str2
        -:  109:    );
        -:  110:
        -:  111:    /** Lexicographically compares lowercase versions of <code>str1</code> and
        -:  112:      * <code>str2</code> and returns a value indicating their relationship.
        -:  113:      * @param str1 Null-terminated string to compare
        -:  114:      * @param str2 Null-terminated string to compare
        -:  115:      * @return The return value indicates the relation of <code>str1</code> to
        -:  116:      * <code>str2</code> as follows
        -:  117:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  118:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  119:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  120:      */
        -:  121:    static int compareIString
        -:  122:    (
        -:  123:        const   XMLCh* const    str1
        -:  124:        , const XMLCh* const    str2
        -:  125:    );
        -:  126:
        -:  127:    /** Lexicographically compares lowercase versions of <code>str1</code> and
        -:  128:      * <code>str2</code> and returns a value indicating their relationship.
        -:  129:      * The routine only lowercases A to Z.
        -:  130:      * @param str1 Null-terminated ASCII string to compare
        -:  131:      * @param str2 Null-terminated ASCII string to compare
        -:  132:      * @return The return value indicates the relation of <code>str1</code> to
        -:  133:      * <code>str2</code> as follows
        -:  134:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  135:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  136:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  137:      */
        -:  138:    static int compareIStringASCII
        -:  139:    (
        -:  140:        const   XMLCh* const    str1
        -:  141:        , const XMLCh* const    str2
        -:  142:    );
        -:  143:
        -:  144:
        -:  145:
        -:  146:    /** Lexicographically compares, at most, the first count characters in
        -:  147:      * <code>str1</code> and <code>str2</code> and returns a value indicating the
        -:  148:      * relationship between the substrings.
        -:  149:      * @param str1 Null-terminated string to compare
        -:  150:      * @param str2 Null-terminated string to compare
        -:  151:      * @param count The number of characters to compare
        -:  152:      *
        -:  153:      * @return The return value indicates the relation of <code>str1</code> to
        -:  154:      * <code>str2</code> as follows
        -:  155:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  156:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  157:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  158:      */
        -:  159:    static int compareNString
        -:  160:    (
        -:  161:        const   char* const     str1
        -:  162:        , const char* const     str2
        -:  163:        , const XMLSize_t       count
        -:  164:    );
        -:  165:
        -:  166:    /** Lexicographically compares, at most, the first count characters in
        -:  167:      * <code>str1</code> and <code>str2</code> and returns a value indicating
        -:  168:      * the relationship between the substrings.
        -:  169:      * @param str1 Null-terminated string to compare
        -:  170:      * @param str2 Null-terminated string to compare
        -:  171:      * @param count The number of characters to compare
        -:  172:      *
        -:  173:      * @return The return value indicates the relation of <code>str1</code> to
        -:  174:      * <code>str2</code> as follows
        -:  175:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  176:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  177:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  178:      */
        -:  179:    static int compareNString
        -:  180:    (
        -:  181:        const   XMLCh* const    str1
        -:  182:        , const XMLCh* const    str2
        -:  183:        , const XMLSize_t       count
        -:  184:    );
        -:  185:
        -:  186:
        -:  187:    /** Lexicographically compares, at most, the first count characters in
        -:  188:      * <code>str1</code> and <code>str2</code> without regard to case and
        -:  189:      * returns a value indicating the relationship between the substrings.
        -:  190:      *
        -:  191:      * @param str1 Null-terminated string to compare
        -:  192:      * @param str2 Null-terminated string to compare
        -:  193:      * @param count The number of characters to compare
        -:  194:      * @return The return value indicates the relation of <code>str1</code> to
        -:  195:      * <code>str2</code> as follows
        -:  196:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  197:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  198:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  199:      */
        -:  200:    static int compareNIString
        -:  201:    (
        -:  202:        const   char* const     str1
        -:  203:        , const char* const     str2
        -:  204:        , const XMLSize_t       count
        -:  205:    );
        -:  206:
        -:  207:    /** Lexicographically compares, at most, the first count characters in
        -:  208:      * <code>str1</code> and <code>str2</code> without regard to case and
        -:  209:      * returns a value indicating the relationship between the substrings.
        -:  210:      *
        -:  211:      * @param str1 Null-terminated string to compare
        -:  212:      * @param str2 Null-terminated string to compare
        -:  213:      * @param count The number of characters to compare
        -:  214:      *
        -:  215:      * @return The return value indicates the relation of <code>str1</code> to
        -:  216:      * <code>str2</code> as follows
        -:  217:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  218:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  219:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  220:      */
        -:  221:    static int compareNIString
        -:  222:    (
        -:  223:        const   XMLCh* const    str1
        -:  224:        , const XMLCh* const    str2
        -:  225:        , const XMLSize_t       count
        -:  226:    );
        -:  227:
        -:  228:    /** Lexicographically compares <code>str1</code> and <code>str2</code> and
        -:  229:      * returns a value indicating their relationship.
        -:  230:      *
        -:  231:      * @param str1 Null-terminated string to compare
        -:  232:      * @param str2 Null-terminated string to compare
        -:  233:      *
        -:  234:      * @return The return value indicates the relation of <code>str1</code> to
        -:  235:      * <code>str2</code> as follows
        -:  236:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  237:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  238:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  239:      */
        -:  240:    static int compareString
        -:  241:    (
        -:  242:        const   char* const     str1
        -:  243:        , const char* const     str2
        -:  244:    );
        -:  245:
        -:  246:    /** Lexicographically compares <code>str1</code> and <code>str2</code> and
        -:  247:      * returns a value indicating their relationship.
        -:  248:      *
        -:  249:      * @param str1 Null-terminated string to compare
        -:  250:      * @param str2 Null-terminated string to compare
        -:  251:      * @return The return value indicates the relation of <code>str1</code> to
        -:  252:      * <code>str2</code> as follows
        -:  253:      *  Less than 0 means <code>str1</code> is less than <code>str2</code>
        -:  254:      *  Equal to 0 means <code>str1</code> is identical to <code>str2</code>
        -:  255:      *  Greater than 0 means <code>str1</code> is more than <code>str2</code>
        -:  256:      */
        -:  257:    static int compareString
        -:  258:    (
        -:  259:        const   XMLCh* const    str1
        -:  260:        , const XMLCh* const    str2
        -:  261:    );
        -:  262:
        -:  263:    /** compares <code>str1</code> and <code>str2</code>
        -:  264:      *
        -:  265:      * @param str1 Null-terminated string to compare
        -:  266:      * @param str2 Null-terminated string to compare
        -:  267:      * @return true if two strings are equal, false if not
        -:  268:      *  If one string is null, while the other is zero-length string,
        -:  269:      *  it is considered as equal.
        -:  270:      */
        -:  271:    static bool equals
        -:  272:    (
        -:  273:          const XMLCh* str1
        -:  274:        , const XMLCh* str2
        -:  275:    );
        -:  276:
        -:  277:    /** compares <code>str1</code> and <code>str2</code>
        -:  278:      *
        -:  279:      * @param str1 string to compare
        -:  280:      * @param str2 string to compare
        -:  281:      * @param n number of characters to compare
        -:  282:      * @return true if two strings are equal, false if not
        -:  283:      *  If one string is null, while the other is zero-length string,
        -:  284:      *  it is considered as equal.
        -:  285:      */
        -:  286:    static bool equalsN
        -:  287:    (
        -:  288:          const XMLCh* str1
        -:  289:        , const XMLCh* str2
        -:  290:        , XMLSize_t n
        -:  291:    );
        -:  292:
        -:  293:    static bool equals
        -:  294:    (
        -:  295:          const char* str1
        -:  296:        , const char* str2
        -:  297:    );
        -:  298:
        -:  299:    /** compares <code>str1</code> and <code>str2</code>
        -:  300:      *
        -:  301:      * @param str1 string to compare
        -:  302:      * @param str2 string to compare
        -:  303:      * @param n number of characters to compare
        -:  304:      * @return true if two strings are equal, false if not
        -:  305:      *  If one string is null, while the other is zero-length string,
        -:  306:      *  it is considered as equal.
        -:  307:      */
        -:  308:    static bool equalsN
        -:  309:    (
        -:  310:          const char* str1
        -:  311:        , const char* str2
        -:  312:        , XMLSize_t n
        -:  313:    );
        -:  314:
        -:  315:	/** Lexicographically compares <code>str1</code> and <code>str2</code>
        -:  316:	  * regions and returns true if they are equal, otherwise false.
        -:  317:	  *
        -:  318:      * A substring of <code>str1</code> is compared to a substring of
        -:  319:	  * <code>str2</code>. The result is true if these substrings represent
        -:  320:	  * identical character sequences. The substring of <code>str1</code>
        -:  321:      * to be compared begins at offset1 and has length charCount. The
        -:  322:	  * substring of <code>str2</code> to be compared begins at offset2 and
        -:  323:	  * has length charCount. The result is false if and only if at least
        -:  324:      * one of the following is true:
        -:  325:      *   offset1 is negative.
        -:  326:      *   offset2 is negative.
        -:  327:      *   offset1+charCount is greater than the length of str1.
        -:  328:      *   offset2+charCount is greater than the length of str2.
        -:  329:      *   There is some nonnegative integer k less than charCount such that:
        -:  330:      *   str1.charAt(offset1+k) != str2.charAt(offset2+k)
        -:  331:      *
        -:  332:      * @param str1 Null-terminated string to compare
        -:  333:	  * @param offset1 Starting offset of str1
        -:  334:      * @param str2 Null-terminated string to compare
        -:  335:	  * @param offset2 Starting offset of str2
        -:  336:	  * @param charCount The number of characters to compare
        -:  337:      * @return true if the specified subregion of <code>str1</code> exactly
        -:  338:	  *  matches the specified subregion of <code>str2></code>; false
        -:  339:	  *  otherwise.
        -:  340:      */
        -:  341:    static bool regionMatches
        -:  342:    (
        -:  343:        const   XMLCh* const    str1
        -:  344:		, const	int				offset1
        -:  345:        , const XMLCh* const    str2
        -:  346:		, const int				offset2
        -:  347:		, const XMLSize_t       charCount
        -:  348:    );
        -:  349:
        -:  350:	/** Lexicographically compares <code>str1</code> and <code>str2</code>
        -:  351:	  * regions without regard to case and returns true if they are equal,
        -:  352:	  * otherwise false.
        -:  353:	  *
        -:  354:      * A substring of <code>str1</code> is compared to a substring of
        -:  355:	  * <code>str2</code>. The result is true if these substrings represent
        -:  356:	  * identical character sequences. The substring of <code>str1</code>
        -:  357:      * to be compared begins at offset1 and has length charCount. The
        -:  358:	  * substring of <code>str2</code> to be compared begins at offset2 and
        -:  359:	  * has length charCount. The result is false if and only if at least
        -:  360:      * one of the following is true:
        -:  361:      *   offset1 is negative.
        -:  362:      *   offset2 is negative.
        -:  363:      *   offset1+charCount is greater than the length of str1.
        -:  364:      *   offset2+charCount is greater than the length of str2.
        -:  365:      *   There is some nonnegative integer k less than charCount such that:
        -:  366:      *   str1.charAt(offset1+k) != str2.charAt(offset2+k)
        -:  367:      *
        -:  368:      * @param str1 Null-terminated string to compare
        -:  369:	  * @param offset1 Starting offset of str1
        -:  370:      * @param str2 Null-terminated string to compare
        -:  371:	  * @param offset2 Starting offset of str2
        -:  372:	  * @param charCount The number of characters to compare
        -:  373:      * @return true if the specified subregion of <code>str1</code> exactly
        -:  374:	  *  matches the specified subregion of <code>str2></code>; false
        -:  375:	  *  otherwise.
        -:  376:      */
        -:  377:    static bool regionIMatches
        -:  378:    (
        -:  379:        const   XMLCh* const    str1
        -:  380:		, const	int				offset1
        -:  381:        , const XMLCh* const    str2
        -:  382:		, const int				offset2
        -:  383:		, const XMLSize_t       charCount
        -:  384:    );
        -:  385:    //@}
        -:  386:
        -:  387:    /** @name String copy functions */
        -:  388:    //@{
        -:  389:    /** Copies <code>src</code>, including the terminating null character, to the
        -:  390:      * location specified by <code>target</code>.
        -:  391:      *
        -:  392:      * No overflow checking is performed when strings are copied or appended.
        -:  393:      * The behavior of strcpy is undefined if the source and destination strings
        -:  394:      * overlap.
        -:  395:      *
        -:  396:      * @param target Destination string
        -:  397:      * @param src Null-terminated source string
        -:  398:      */
        -:  399:    static void copyString
        -:  400:    (
        -:  401:                char* const     target
        -:  402:        , const char* const     src
        -:  403:    );
        -:  404:
        -:  405:    /** Copies <code>src</code>, including the terminating null character, to
        -:  406:      *   the location specified by <code>target</code>.
        -:  407:      *
        -:  408:      * No overflow checking is performed when strings are copied or appended.
        -:  409:      * The behavior of <code>copyString</code> is undefined if the source and
        -:  410:      * destination strings overlap.
        -:  411:      *
        -:  412:      * @param target Destination string
        -:  413:      * @param src Null-terminated source string
        -:  414:      */
        -:  415:    static void copyString
        -:  416:    (
        -:  417:                XMLCh* const    target
        -:  418:        , const XMLCh* const    src
        -:  419:    );
        -:  420:
        -:  421:    /** Copies <code>src</code>, upto a fixed number of characters, to the
        -:  422:      * location specified by <code>target</code>.
        -:  423:      *
        -:  424:      * No overflow checking is performed when strings are copied or appended.
        -:  425:      * The behavior of <code>copyNString</code> is undefined if the source and
        -:  426:      * destination strings overlap.
        -:  427:      *
        -:  428:      * @param target Destination string. The size of the buffer should
        -:  429:      *        atleast be 'maxChars + 1'.
        -:  430:      * @param src Null-terminated source string
        -:  431:      * @param maxChars The maximum number of characters to copy
        -:  432:      */
        -:  433:    static bool copyNString
        -:  434:    (
        -:  435:                XMLCh* const   target
        -:  436:        , const XMLCh* const   src
        -:  437:        , const XMLSize_t      maxChars
        -:  438:    );
        -:  439:    //@}
        -:  440:
        -:  441:    /** @name Hash functions */
        -:  442:    //@{
        -:  443:    /** Hashes a string given a modulus
        -:  444:      *
        -:  445:      * @param toHash The string to hash
        -:  446:      * @param hashModulus The divisor to be used for hashing
        -:  447:      * @return Returns the hash value
        -:  448:      */
        -:  449:    static XMLSize_t hash
        -:  450:    (
        -:  451:        const   char* const     toHash
        -:  452:        , const XMLSize_t       hashModulus
        -:  453:    );
        -:  454:
        -:  455:    /** Hashes a string given a modulus
        -:  456:      *
        -:  457:      * @param toHash The string to hash
        -:  458:      * @param hashModulus The divisor to be used for hashing
        -:  459:      * @return Returns the hash value
        -:  460:      */
        -:  461:    static XMLSize_t hash
        -:  462:    (
        -:  463:        const   XMLCh* const    toHash
        -:  464:        , const XMLSize_t       hashModulus
        -:  465:    );
        -:  466:
        -:  467:    /** Hashes a string given a modulus taking a maximum number of characters
        -:  468:      * as the limit
        -:  469:      *
        -:  470:      * @param toHash The string to hash
        -:  471:      * @param numChars The maximum number of characters to consider for hashing
        -:  472:      * @param hashModulus The divisor to be used for hashing
        -:  473:      * @return Returns the hash value
        -:  474:      */
        -:  475:    static XMLSize_t hashN
        -:  476:    (
        -:  477:        const   XMLCh* const    toHash
        -:  478:        , const XMLSize_t       numChars
        -:  479:        , const XMLSize_t       hashModulus
        -:  480:    );
        -:  481:
        -:  482:    //@}
        -:  483:
        -:  484:    /** @name Search functions */
        -:  485:    //@{
        -:  486:    /**
        -:  487:      * Provides the index of the first occurrence of a character within a string
        -:  488:      *
        -:  489:      * @param toSearch The string to search
        -:  490:      * @param ch The character to search within the string
        -:  491:      * @return If found, returns the index of the character within the string,
        -:  492:      * else returns -1.
        -:  493:      */
        -:  494:    static int indexOf(const char* const toSearch, const char ch);
        -:  495:
        -:  496:    /**
        -:  497:      * Provides the index of the first occurrence of a character within a string
        -:  498:      *
        -:  499:      * @param toSearch The string to search
        -:  500:      * @param ch The character to search within the string
        -:  501:      * @return If found, returns the index of the character within the string,
        -:  502:      * else returns -1.
        -:  503:      */
        -:  504:    static int indexOf(const XMLCh* const toSearch, const XMLCh ch);
        -:  505:
        -:  506:	    /**
        -:  507:      * Provides the index of the first occurrence of a character within a string
        -:  508:      * starting from a given index
        -:  509:      *
        -:  510:      * @param toSearch The string to search
        -:  511:      * @param chToFind The character to search within the string
        -:  512:      * @param fromIndex The index to start searching from
        -:  513:      * @param manager The MemoryManager to use to allocate objects
        -:  514:      * @return If found, returns the index of the character within the string,
        -:  515:      * else returns -1.
        -:  516:      */
        -:  517:    static int indexOf
        -:  518:    (
        -:  519:        const   char* const     toSearch
        -:  520:        , const char            chToFind
        -:  521:        , const XMLSize_t       fromIndex
        -:  522:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  523:    );
        -:  524:
        -:  525:    /**
        -:  526:      * Provides the index of the first occurrence of a character within a string
        -:  527:      * starting from a given index
        -:  528:      *
        -:  529:      * @param toSearch The string to search
        -:  530:      * @param chToFind The character to search within the string
        -:  531:      * @param fromIndex The index to start searching from
        -:  532:      * @param manager The MemoryManager to use to allocate objects
        -:  533:      * @return If found, returns the index of the character within the string,
        -:  534:      * else returns -1.
        -:  535:      */
        -:  536:    static int indexOf
        -:  537:    (
        -:  538:        const   XMLCh* const    toSearch
        -:  539:        , const XMLCh           chToFind
        -:  540:        , const XMLSize_t       fromIndex
        -:  541:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  542:    );
        -:  543:
        -:  544:    /**
        -:  545:      * Provides the index of the last occurrence of a character within a string
        -:  546:      *
        -:  547:      * @param toSearch The string to search
        -:  548:      * @param ch The character to search within the string
        -:  549:      * @return If found, returns the index of the character within the string,
        -:  550:      * else returns -1.
        -:  551:      */
        -:  552:    static int lastIndexOf(const char* const toSearch, const char ch);
        -:  553:
        -:  554:    /**
        -:  555:      * Provides the index of the last occurrence of a character within a string
        -:  556:      *
        -:  557:      * @param toSearch The string to search
        -:  558:      * @param ch The character to search within the string
        -:  559:      * @return If found, returns the index of the character within the string,
        -:  560:      * else returns -1.
        -:  561:      */
        -:  562:    static int lastIndexOf(const XMLCh* const toSearch, const XMLCh ch);
        -:  563:
        -:  564:    /**
        -:  565:      * Provides the index of the last occurrence of a character within a string
        -:  566:      *
        -:  567:      * @param ch The character to search within the string
        -:  568:      * @param toSearch The string to search
        -:  569:      * @param toSearchLen The length of the string to search
        -:  570:      * @return If found, returns the index of the character within the string,
        -:  571:      * else returns -1.
        -:  572:      */
        -:  573:    static int lastIndexOf
        -:  574:    (
        -:  575:        const XMLCh ch
        -:  576:        , const XMLCh* const toSearch
        -:  577:        , const XMLSize_t    toSearchLen
        -:  578:    );
        -:  579:
        -:  580:    /**
        -:  581:      * Provides the index of the last occurrence of a character within a string
        -:  582:      * starting backward from a given index
        -:  583:      *
        -:  584:      * @param toSearch The string to search
        -:  585:      * @param chToFind The character to search within the string
        -:  586:      * @param fromIndex The index to start backward search from
        -:  587:      * @param manager The MemoryManager to use to allocate objects
        -:  588:      * @return If found, returns the index of the character within the string,
        -:  589:      * else returns -1.
        -:  590:      */
        -:  591:    static int lastIndexOf
        -:  592:    (
        -:  593:        const   char* const     toSearch
        -:  594:        , const char            chToFind
        -:  595:        , const XMLSize_t       fromIndex
        -:  596:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  597:    );
        -:  598:
        -:  599:    /**
        -:  600:      * Provides the index of the last occurrence of a character within a string
        -:  601:      * starting backward from a given index
        -:  602:      *
        -:  603:      * @param toSearch The string to search
        -:  604:      * @param ch       The character to search within the string
        -:  605:      * @param fromIndex The index to start backward search from
        -:  606:      * @param manager The MemoryManager to use to allocate objects
        -:  607:      * @return If found, returns the index of the character within the string,
        -:  608:      * else returns -1.
        -:  609:      */
        -:  610:    static int lastIndexOf
        -:  611:    (
        -:  612:        const   XMLCh* const    toSearch
        -:  613:        , const XMLCh           ch
        -:  614:        , const XMLSize_t       fromIndex
        -:  615:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  616:    );
        -:  617:    //@}
        -:  618:
        -:  619:    /** @name Fixed size string movement */
        -:  620:    //@{
        -:  621:    /** Moves X number of chars
        -:  622:      * @param targetStr The string to copy the chars to
        -:  623:      * @param srcStr The string to copy the chars from
        -:  624:      * @param count The number of chars to move
        -:  625:      */
        -:  626:    static void moveChars
        -:  627:    (
        -:  628:                XMLCh* const    targetStr
        -:  629:        , const XMLCh* const    srcStr
        -:  630:        , const XMLSize_t       count
        -:  631:    );
        -:  632:
        -:  633:    //@}
        -:  634:
        -:  635:    /** @name Substring function */
        -:  636:    //@{
        -:  637:    /** Create a substring of a given string. The substring begins at the
        -:  638:      * specified beginIndex and extends to the character at index
        -:  639:      * endIndex - 1.
        -:  640:      * @param targetStr The string to copy the chars to
        -:  641:      * @param srcStr The string to copy the chars from
        -:  642:      * @param startIndex beginning index, inclusive.
        -:  643:      * @param endIndex the ending index, exclusive.
        -:  644:      * @param manager The MemoryManager to use to allocate objects
        -:  645:      */
        -:  646:    static void subString
        -:  647:    (
        -:  648:                char* const    targetStr
        -:  649:        , const char* const    srcStr
        -:  650:        , const XMLSize_t      startIndex
        -:  651:        , const XMLSize_t      endIndex
        -:  652:        , MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager
        -:  653:    );
        -:  654:
        -:  655:    /** Create a substring of a given string. The substring begins at the
        -:  656:      * specified beginIndex and extends to the character at index
        -:  657:      * endIndex - 1.
        -:  658:      * @param targetStr The string to copy the chars to
        -:  659:      * @param srcStr The string to copy the chars from
        -:  660:      * @param startIndex beginning index, inclusive.
        -:  661:      * @param endIndex the ending index, exclusive.
        -:  662:      * @param manager The MemoryManager to use to allocate objects
        -:  663:      */
        -:  664:    static void subString
        -:  665:    (
        -:  666:                XMLCh* const    targetStr
        -:  667:        , const XMLCh* const    srcStr
        -:  668:        , const XMLSize_t       startIndex
        -:  669:        , const XMLSize_t       endIndex
        -:  670:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  671:    );
        -:  672:
        -:  673:    /** Create a substring of a given string. The substring begins at the
        -:  674:      * specified beginIndex and extends to the character at index
        -:  675:      * endIndex - 1.
        -:  676:      * @param targetStr The string to copy the chars to
        -:  677:      * @param srcStr The string to copy the chars from
        -:  678:      * @param startIndex beginning index, inclusive.
        -:  679:      * @param endIndex the ending index, exclusive.
        -:  680:      * @param srcStrLength the length of srcStr
        -:  681:      * @param manager The MemoryManager to use to allocate objects
        -:  682:      */
        -:  683:    static void subString
        -:  684:    (
        -:  685:                XMLCh* const    targetStr
        -:  686:        , const XMLCh* const    srcStr
        -:  687:        , const XMLSize_t       startIndex
        -:  688:        , const XMLSize_t       endIndex
        -:  689:        , const XMLSize_t       srcStrLength
        -:  690:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  691:    );
        -:  692:
        -:  693:    //@}
        -:  694:
        -:  695:    /** @name Replication function */
        -:  696:    //@{
        -:  697:    /** Replicates a string
        -:  698:      * NOTE: The returned buffer is allocated with the MemoryManager. It is the
        -:  699:      * responsibility of the caller to delete it when not longer needed.
        -:  700:      * You can call XMLString::release to release this returned buffer.
        -:  701:      *
        -:  702:      * @param toRep The string to replicate
        -:  703:      * @param manager The MemoryManager to use to allocate the string
        -:  704:      * @return Returns a pointer to the replicated string
        -:  705:      * @see   XMLString::release(char**, MemoryManager*)
        -:  706:      */
        -:  707:    static char* replicate(const char* const toRep,
        -:  708:                           MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager);
        -:  709:
        -:  710:    /** Replicates a string
        -:  711:      * NOTE: The returned buffer is allocated with the MemoryManager. It is the
        -:  712:      * responsibility of the caller to delete it when not longer needed.
        -:  713:      * You can call XMLString::release to release this returned buffer.
        -:  714:      *
        -:  715:      * @param toRep The string to replicate
        -:  716:      * @param manager The MemoryManager to use to allocate the string
        -:  717:      * @return Returns a pointer to the replicated string
        -:  718:      * @see   XMLString::release(XMLCh**, MemoryManager*)
        -:  719:      */
        -:  720:    static XMLCh* replicate(const XMLCh* const toRep,
        -:  721:                            MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager);
        -:  722:
        -:  723:    //@}
        -:  724:
        -:  725:    /** @name String query function */
        -:  726:    //@{
        -:  727:    /** Tells if the sub-string appears within a string at the beginning
        -:  728:      * @param toTest The string to test
        -:  729:      * @param prefix The sub-string that needs to be checked
        -:  730:      * @return Returns true if the sub-string was found at the beginning of
        -:  731:      * <code>toTest</code>, else false
        -:  732:      */
        -:  733:    static bool startsWith
        -:  734:    (
        -:  735:        const   char* const     toTest
        -:  736:        , const char* const     prefix
        -:  737:    );
        -:  738:
        -:  739:    /** Tells if the sub-string appears within a string at the beginning
        -:  740:      * @param toTest The string to test
        -:  741:      * @param prefix The sub-string that needs to be checked
        -:  742:      * @return Returns true if the sub-string was found at the beginning of
        -:  743:      * <code>toTest</code>, else false
        -:  744:      */
        -:  745:    static bool startsWith
        -:  746:    (
        -:  747:        const   XMLCh* const    toTest
        -:  748:        , const XMLCh* const    prefix
        -:  749:    );
        -:  750:
        -:  751:    /** Tells if the sub-string appears within a string at the beginning
        -:  752:      * without regard to case
        -:  753:      *
        -:  754:      * @param toTest The string to test
        -:  755:      * @param prefix The sub-string that needs to be checked
        -:  756:      * @return Returns true if the sub-string was found at the beginning of
        -:  757:      * <code>toTest</code>, else false
        -:  758:      */
        -:  759:    static bool startsWithI
        -:  760:    (
        -:  761:        const   char* const     toTest
        -:  762:        , const char* const     prefix
        -:  763:    );
        -:  764:
        -:  765:    /** Tells if the sub-string appears within a string at the beginning
        -:  766:      * without regard to case
        -:  767:      *
        -:  768:      * @param toTest The string to test
        -:  769:      * @param prefix The sub-string that needs to be checked
        -:  770:      *
        -:  771:      * @return Returns true if the sub-string was found at the beginning
        -:  772:      * of <code>toTest</code>, else false
        -:  773:      */
        -:  774:    static bool startsWithI
        -:  775:    (
        -:  776:        const   XMLCh* const    toTest
        -:  777:        , const XMLCh* const    prefix
        -:  778:    );
        -:  779:
        -:  780:    /** Tells if the sub-string appears within a string at the end.
        -:  781:      * @param toTest The string to test
        -:  782:      * @param suffix The sub-string that needs to be checked
        -:  783:      * @return Returns true if the sub-string was found at the end of
        -:  784:      * <code>toTest</code>, else false
        -:  785:      */
        -:  786:    static bool endsWith
        -:  787:    (
        -:  788:        const   XMLCh* const    toTest
        -:  789:        , const XMLCh* const    suffix
        -:  790:    );
        -:  791:
        -:  792:
        -:  793:    /** Tells if a string has any occurrence of any character of another
        -:  794:      * string within itself
        -:  795:      * @param toSearch The string to be searched
        -:  796:      * @param searchList The string from which characters to be searched for are drawn
        -:  797:      * @return Returns the pointer to the location where the first occurrence of any
        -:  798:      * character from searchList is found,
        -:  799:      * else returns 0
        -:  800:      */
        -:  801:    static const XMLCh* findAny
        -:  802:    (
        -:  803:        const   XMLCh* const    toSearch
        -:  804:        , const XMLCh* const    searchList
        -:  805:    );
        -:  806:
        -:  807:    /** Tells if a string has any occurrence of any character of another
        -:  808:      * string within itself
        -:  809:      * @param toSearch The string to be searched
        -:  810:      * @param searchList The string from which characters to be searched for are drawn
        -:  811:      * @return Returns the pointer to the location where the first occurrence of any
        -:  812:      * character from searchList is found,
        -:  813:      * else returns 0
        -:  814:      */
        -:  815:    static XMLCh* findAny
        -:  816:    (
        -:  817:                XMLCh* const    toSearch
        -:  818:        , const XMLCh* const    searchList
        -:  819:    );
        -:  820:
        -:  821:    /** Tells if a string has pattern within itself
        -:  822:      * @param toSearch The string to be searched
        -:  823:      * @param pattern The pattern to be located within the string
        -:  824:      * @return Returns index to the location where the pattern was
        -:  825:      * found, else returns -1
        -:  826:      */
        -:  827:    static int patternMatch
        -:  828:    (
        -:  829:          const XMLCh* const    toSearch
        -:  830:        , const XMLCh* const    pattern
        -:  831:    );
        -:  832:
        -:  833:    /** Get the length of the string
        -:  834:      * @param src The string whose length is to be determined
        -:  835:      * @return Returns the length of the string
        -:  836:      */
        -:  837:    static XMLSize_t stringLen(const char* const src);
        -:  838:
        -:  839:    /** Get the length of the string
        -:  840:      * @param src The string whose length is to be determined
        -:  841:      * @return Returns the length of the string
        -:  842:      */
        -:  843:    static XMLSize_t stringLen(const XMLCh* const src);
        -:  844:
        -:  845:    /**
        -:  846:      *
        -:  847:      * Checks whether an name is a valid NOTATION according to XML 1.0
        -:  848:      * @param name    The string to check its NOTATION validity
        -:  849:      * @param manager The memory manager
        -:  850:      * @return Returns true if name is NOTATION valid, otherwise false
        -:  851:      */
        -:  852:    static bool isValidNOTATION(const XMLCh*         const name
        -:  853:                              ,       MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager);
        -:  854:
        -:  855:    /**
        -:  856:      * Checks whether an name is a valid EncName.
        -:  857:      * @param name The string to check its EncName validity
        -:  858:      * @return Returns true if name is EncName valid, otherwise false
        -:  859:      */
        -:  860:    static bool isValidEncName(const XMLCh* const name);
        -:  861:
        -:  862:    /**
        -:  863:      * Checks whether a character is within [a-zA-Z].
        -:  864:      * @param theChar the character to check
        -:  865:      * @return Returns true if within the range, otherwise false
        -:  866:      */
        -:  867:
        -:  868:    static bool isAlpha(XMLCh const theChar);
        -:  869:
        -:  870:    /**
        -:  871:      * Checks whether a character is within [0-9].
        -:  872:      * @param theChar the character to check
        -:  873:      * @return Returns true if within the range, otherwise false
        -:  874:      */
        -:  875:    static bool isDigit(XMLCh const theChar);
        -:  876:
        -:  877:    /**
        -:  878:      * Checks whether a character is within [0-9a-zA-Z].
        -:  879:      * @param theChar the character to check
        -:  880:      * @return Returns true if within the range, otherwise false
        -:  881:      */
        -:  882:    static bool isAlphaNum(XMLCh const theChar);
        -:  883:
        -:  884:    /**
        -:  885:      * Checks whether a character is within [0-9a-fA-F].
        -:  886:      * @param theChar the character to check
        -:  887:      * @return Returns true if within the range, otherwise false
        -:  888:      */
        -:  889:    static bool isHex(XMLCh const theChar);
        -:  890:
        -:  891:    /** Find is the string appears in the enum list
        -:  892:      * @param toFind the string to be found
        -:  893:      * @param enumList the list
        -:  894:      * return true if found
        -:  895:      */
        -:  896:    static bool isInList(const XMLCh* const toFind, const XMLCh* const enumList);
        -:  897:
        -:  898:    //@}
        -:  899:
        -:  900:    /** @name Conversion functions */
        -:  901:    //@{
        -:  902:
        -:  903:      /** Converts size to a text string based a given radix
        -:  904:      *
        -:  905:      * @param toFormat The size to convert
        -:  906:      * @param toFill The buffer that will hold the output on return. The
        -:  907:      *        size of this buffer should at least be 'maxChars + 1'.
        -:  908:      * @param maxChars The maximum number of output characters that can be
        -:  909:      *         accepted. If the result will not fit, it is an error.
        -:  910:      * @param radix The radix of the input data, based on which the conversion
        -:  911:      * @param manager The MemoryManager to use to allocate objects
        -:  912:      * will be done
        -:  913:      */
        -:  914:    static void sizeToText
        -:  915:    (
        -:  916:        const   XMLSize_t           toFormat
        -:  917:        ,       char* const         toFill
        -:  918:        , const XMLSize_t           maxChars
        -:  919:        , const unsigned int        radix
        -:  920:        , MemoryManager* const      manager = XMLPlatformUtils::fgMemoryManager
        -:  921:    );
        -:  922:
        -:  923:    /** Converts size to a text string based a given radix
        -:  924:      *
        -:  925:      * @param toFormat The size to convert
        -:  926:      * @param toFill The buffer that will hold the output on return. The
        -:  927:      *        size of this buffer should at least be 'maxChars + 1'.
        -:  928:      * @param maxChars The maximum number of output characters that can be
        -:  929:      *         accepted. If the result will not fit, it is an error.
        -:  930:      * @param radix The radix of the input data, based on which the conversion
        -:  931:      * @param manager The MemoryManager to use to allocate objects
        -:  932:      * will be done
        -:  933:      */
        -:  934:    static void sizeToText
        -:  935:    (
        -:  936:        const   XMLSize_t           toFormat
        -:  937:        ,       XMLCh* const        toFill
        -:  938:        , const XMLSize_t           maxChars
        -:  939:        , const unsigned int        radix
        -:  940:        , MemoryManager* const      manager = XMLPlatformUtils::fgMemoryManager
        -:  941:    );
        -:  942:
        -:  943:    /** Converts binary data to a text string based a given radix
        -:  944:      *
        -:  945:      * @param toFormat The number to convert
        -:  946:      * @param toFill The buffer that will hold the output on return. The
        -:  947:      *        size of this buffer should at least be 'maxChars + 1'.
        -:  948:      * @param maxChars The maximum number of output characters that can be
        -:  949:      *         accepted. If the result will not fit, it is an error.
        -:  950:      * @param radix The radix of the input data, based on which the conversion
        -:  951:      * @param manager The MemoryManager to use to allocate objects
        -:  952:      * will be done
        -:  953:      */
        -:  954:    static void binToText
        -:  955:    (
        -:  956:        const   unsigned int    toFormat
        -:  957:        ,       char* const     toFill
        -:  958:        , const XMLSize_t       maxChars
        -:  959:        , const unsigned int    radix
        -:  960:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  961:    );
        -:  962:
        -:  963:    /** Converts binary data to a text string based a given radix
        -:  964:      *
        -:  965:      * @param toFormat The number to convert
        -:  966:      * @param toFill The buffer that will hold the output on return. The
        -:  967:      *        size of this buffer should at least be 'maxChars + 1'.
        -:  968:      * @param maxChars The maximum number of output characters that can be
        -:  969:      *         accepted. If the result will not fit, it is an error.
        -:  970:      * @param radix The radix of the input data, based on which the conversion
        -:  971:      * @param manager The MemoryManager to use to allocate objects
        -:  972:      * will be done
        -:  973:      */
        -:  974:    static void binToText
        -:  975:    (
        -:  976:        const   unsigned int    toFormat
        -:  977:        ,       XMLCh* const    toFill
        -:  978:        , const XMLSize_t       maxChars
        -:  979:        , const unsigned int    radix
        -:  980:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -:  981:    );
        -:  982:
        -:  983:    /** Converts binary data to a text string based a given radix
        -:  984:      *
        -:  985:      * @param toFormat The number to convert
        -:  986:      * @param toFill The buffer that will hold the output on return. The
        -:  987:      *        size of this buffer should at least be 'maxChars + 1'.
        -:  988:      * @param maxChars The maximum number of output characters that can be
        -:  989:      *         accepted. If the result will not fit, it is an error.
        -:  990:      * @param radix The radix of the input data, based on which the conversion
        -:  991:      * @param manager The MemoryManager to use to allocate objects
        -:  992:      * will be done
        -:  993:      */
        -:  994:    static void binToText
        -:  995:    (
        -:  996:        const   unsigned long   toFormat
        -:  997:        ,       char* const     toFill
        -:  998:        , const XMLSize_t       maxChars
        -:  999:        , const unsigned int    radix
        -: 1000:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1001:    );
        -: 1002:
        -: 1003:    /** Converts binary data to a text string based a given radix
        -: 1004:      *
        -: 1005:      * @param toFormat The number to convert
        -: 1006:      * @param toFill The buffer that will hold the output on return. The
        -: 1007:      *        size of this buffer should at least be 'maxChars + 1'.
        -: 1008:      * @param maxChars The maximum number of output characters that can be
        -: 1009:      *         accepted. If the result will not fit, it is an error.
        -: 1010:      * @param radix The radix of the input data, based on which the conversion
        -: 1011:      * @param manager The MemoryManager to use to allocate objects
        -: 1012:      * will be done
        -: 1013:      */
        -: 1014:    static void binToText
        -: 1015:    (
        -: 1016:        const   unsigned long   toFormat
        -: 1017:        ,       XMLCh* const    toFill
        -: 1018:        , const XMLSize_t       maxChars
        -: 1019:        , const unsigned int    radix
        -: 1020:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1021:    );
        -: 1022:
        -: 1023:    /** Converts binary data to a text string based a given radix
        -: 1024:      *
        -: 1025:      * @param toFormat The number to convert
        -: 1026:      * @param toFill The buffer that will hold the output on return. The
        -: 1027:      *        size of this buffer should at least be 'maxChars + 1'.
        -: 1028:      * @param maxChars The maximum number of output characters that can be
        -: 1029:      *         accepted. If the result will not fit, it is an error.
        -: 1030:      * @param radix The radix of the input data, based on which the conversion
        -: 1031:      * @param manager The MemoryManager to use to allocate objects
        -: 1032:      * will be done
        -: 1033:      */
        -: 1034:    static void binToText
        -: 1035:    (
        -: 1036:        const   int             toFormat
        -: 1037:        ,       char* const     toFill
        -: 1038:        , const XMLSize_t       maxChars
        -: 1039:        , const unsigned int    radix
        -: 1040:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1041:    );
        -: 1042:
        -: 1043:    /** Converts binary data to a text string based a given radix
        -: 1044:      *
        -: 1045:      * @param toFormat The number to convert
        -: 1046:      * @param toFill The buffer that will hold the output on return. The
        -: 1047:      *        size of this buffer should at least be 'maxChars + 1'.
        -: 1048:      * @param maxChars The maximum number of output characters that can be
        -: 1049:      *         accepted. If the result will not fit, it is an error.
        -: 1050:      * @param radix The radix of the input data, based on which the conversion
        -: 1051:      * @param manager The MemoryManager to use to allocate objects
        -: 1052:      * will be done
        -: 1053:      */
        -: 1054:    static void binToText
        -: 1055:    (
        -: 1056:        const   int             toFormat
        -: 1057:        ,       XMLCh* const    toFill
        -: 1058:        , const XMLSize_t       maxChars
        -: 1059:        , const unsigned int    radix
        -: 1060:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1061:    );
        -: 1062:
        -: 1063:    /** Converts binary data to a text string based a given radix
        -: 1064:      *
        -: 1065:      * @param toFormat The number to convert
        -: 1066:      * @param toFill The buffer that will hold the output on return. The
        -: 1067:      *        size of this buffer should at least be 'maxChars + 1'.
        -: 1068:      * @param maxChars The maximum number of output characters that can be
        -: 1069:      *         accepted. If the result will not fit, it is an error.
        -: 1070:      * @param radix The radix of the input data, based on which the conversion
        -: 1071:      * @param manager The MemoryManager to use to allocate objects
        -: 1072:      * will be done
        -: 1073:      */
        -: 1074:    static void binToText
        -: 1075:    (
        -: 1076:        const   long            toFormat
        -: 1077:        ,       char* const     toFill
        -: 1078:        , const XMLSize_t       maxChars
        -: 1079:        , const unsigned int    radix
        -: 1080:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1081:    );
        -: 1082:
        -: 1083:    /** Converts binary data to a text string based a given radix
        -: 1084:      *
        -: 1085:      * @param toFormat The number to convert
        -: 1086:      * @param toFill The buffer that will hold the output on return. The
        -: 1087:      *        size of this buffer should at least be 'maxChars + 1'.
        -: 1088:      * @param maxChars The maximum number of output characters that can be
        -: 1089:      *         accepted. If the result will not fit, it is an error.
        -: 1090:      * @param radix The radix of the input data, based on which the conversion
        -: 1091:      * @param manager The MemoryManager to use to allocate objects
        -: 1092:      * will be done
        -: 1093:      */
        -: 1094:    static void binToText
        -: 1095:    (
        -: 1096:        const   long            toFormat
        -: 1097:        ,       XMLCh* const    toFill
        -: 1098:        , const XMLSize_t       maxChars
        -: 1099:        , const unsigned int    radix
        -: 1100:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1101:    );
        -: 1102:
        -: 1103:    /**
        -: 1104:      * Converts a string of decimal chars to a binary value
        -: 1105:      *
        -: 1106:      * Note that leading and trailing whitespace is legal and will be ignored
        -: 1107:      * but the remainder must be all decimal digits.
        -: 1108:      *
        -: 1109:      * @param toConvert The string of digits to convert
        -: 1110:      * @param toFill    The unsigned int value to fill with the converted
        -: 1111:      *                  value.
        -: 1112:      * @param manager The MemoryManager to use to allocate objects
        -: 1113:      */
        -: 1114:    static bool textToBin
        -: 1115:    (
        -: 1116:        const   XMLCh* const    toConvert
        -: 1117:        ,       unsigned int&   toFill
        -: 1118:        ,       MemoryManager*  const manager = XMLPlatformUtils::fgMemoryManager
        -: 1119:    );
        -: 1120:
        -: 1121:    /**
        -: 1122:      * Converts a string of decimal chars to a binary value
        -: 1123:      *
        -: 1124:      * Note that leading and trailing whitespace is legal and will be ignored,
        -: 1125:      *
        -: 1126:      * Only one and either of (+,-) after the leading whitespace, before
        -: 1127:      * any other characters are allowed.
        -: 1128:      *
        -: 1129:      * but the remainder must be all decimal digits.
        -: 1130:      *
        -: 1131:      * @param toConvert The string of digits to convert
        -: 1132:      * @param manager The MemoryManager to use to allocate objects
        -: 1133:      */
        -: 1134:    static int parseInt
        -: 1135:    (
        -: 1136:        const   XMLCh* const    toConvert
        -: 1137:      , MemoryManager* const    manager = XMLPlatformUtils::fgMemoryManager
        -: 1138:    );
        -: 1139:
        -: 1140:    /** Cut leading chars from a string
        -: 1141:      *
        -: 1142:      * @param toCutFrom The string to cut chars from
        -: 1143:      * @param count     The count of leading chars to cut
        -: 1144:      */
        -: 1145:    static void cut
        -: 1146:    (
        -: 1147:                XMLCh* const    toCutFrom
        -: 1148:        , const XMLSize_t       count
        -: 1149:    );
        -: 1150:
        -: 1151:    /** Transcodes a string to native code-page
        -: 1152:      *
        -: 1153:      * NOTE: The returned buffer is dynamically allocated and is the
        -: 1154:      * responsibility of the caller to delete it when not longer needed.
        -: 1155:      * You can call XMLString::release to release this returned buffer.
        -: 1156:      *
        -: 1157:      * @param toTranscode The string to be transcoded
        -: 1158:      * @param manager The MemoryManager to use to allocate objects
        -: 1159:      * @return Returns the transcoded string
        -: 1160:      * @see   XMLString::release(XMLCh**, MemoryManager*)
        -: 1161:      */
        -: 1162:    static char* transcode
        -: 1163:    (
        -: 1164:        const   XMLCh* const         toTranscode
        -: 1165:        ,       MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager
        -: 1166:    );
        -: 1167:
        -: 1168:    /** Transcodes a string to native code-page (DEPRECATED)
        -: 1169:      *
        -: 1170:      * Be aware that when transcoding to an external encoding, that each
        -: 1171:      * Unicode char can create multiple output bytes. So you cannot assume
        -: 1172:      * a one to one correspondence of input chars to output bytes.
        -: 1173:      *
        -: 1174:      * @param toTranscode The string tobe transcoded
        -: 1175:      * @param toFill The buffer that is filled with the transcoded value.
        -: 1176:      *        The size of this buffer should atleast be 'maxChars + 1'.
        -: 1177:      * @param maxChars The maximum number of bytes that the output
        -: 1178:      *         buffer can hold (not including the null, which is why
        -: 1179:      *         toFill should be at least maxChars+1.).
        -: 1180:      * @param manager The MemoryManager to use to allocate objects
        -: 1181:      * @return Returns true if successful, false if there was an error
        -: 1182:      */
        -: 1183:    static bool transcode
        -: 1184:    (
        -: 1185:        const   XMLCh* const    toTranscode
        -: 1186:        ,       char* const     toFill
        -: 1187:        , const XMLSize_t       maxChars
        -: 1188:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1189:    );
        -: 1190:
        -: 1191:    /** Transcodes a string to native code-page
        -: 1192:      *
        -: 1193:      * NOTE: The returned buffer is dynamically allocated and is the
        -: 1194:      * responsibility of the caller to delete it when not longer needed.
        -: 1195:      * You can call XMLString::release to release this returned buffer.
        -: 1196:      *
        -: 1197:      * @param toTranscode The string to be transcoded
        -: 1198:      * @param manager The MemoryManager to use to allocate objects
        -: 1199:      * @return Returns the transcoded string
        -: 1200:      * @see   XMLString::release(char**, MemoryManager*)
        -: 1201:      */
        -: 1202:    static XMLCh* transcode
        -: 1203:    (
        -: 1204:        const   char* const          toTranscode
        -: 1205:        ,       MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager
        -: 1206:    );
        -: 1207:
        -: 1208:    /** Transcodes a string to native code-page (DEPRECATED)
        -: 1209:      * @param toTranscode The string tobe transcoded
        -: 1210:      * @param toFill The buffer that is filled with the transcoded value.
        -: 1211:      *        The size of this buffer should atleast be 'maxChars + 1'.
        -: 1212:      * @param maxChars The maximum number of characters that the output
        -: 1213:      *         buffer can hold (not including the null, which is why
        -: 1214:      *         toFill should be at least maxChars+1.).
        -: 1215:      * @param manager The MemoryManager to use to allocate objects
        -: 1216:      * @return Returns true if successful, false if there was an error
        -: 1217:      */
        -: 1218:    static bool transcode
        -: 1219:    (
        -: 1220:        const   char* const     toTranscode
        -: 1221:        ,       XMLCh* const    toFill
        -: 1222:        , const XMLSize_t       maxChars
        -: 1223:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1224:    );
        -: 1225:
        -: 1226:    /** Trims off extra space characters from the start and end of the string,
        -: 1227:      * moving the non-space string content back to the start.
        -: 1228:      * @param toTrim The string to be trimmed. On return this contains the
        -: 1229:      * trimmed string
        -: 1230:      */
        -: 1231:    static void trim(char* const toTrim);
        -: 1232:
        -: 1233:    /** Trims off extra space characters from the start and end of the string,
        -: 1234:      * moving the non-space string content back to the start.
        -: 1235:      * @param toTrim The string to be trimmed. On return this contains
        -: 1236:      * the trimmed string
        -: 1237:      */
        -: 1238:    static void trim(XMLCh* const toTrim);
        -: 1239:
        -: 1240:    /** Break a string into tokens with space as delimiter, and
        -: 1241:      * stored in a string vector.  The caller owns the string vector
        -: 1242:      * that is returned, and is responsible for deleting it.
        -: 1243:      * @param tokenizeSrc String to be tokenized
        -: 1244:      * @param manager The MemoryManager to use to allocate objects
        -: 1245:      * @return a vector of all the tokenized string
        -: 1246:      */
        -: 1247:    static BaseRefVectorOf<XMLCh>* tokenizeString(const XMLCh* const tokenizeSrc
        -: 1248:                                        , MemoryManager*       const manager = XMLPlatformUtils::fgMemoryManager);
        -: 1249:
        -: 1250:    //@}
        -: 1251:
        -: 1252:    /** @name Formatting functions */
        -: 1253:    //@{
        -: 1254:    /** Creates a UName from a URI and base name. It is in the form
        -: 1255:      * {url}name, and is commonly used internally to represent fully
        -: 1256:      * qualified names when namespaces are enabled.
        -: 1257:      *
        -: 1258:      * @param pszURI The URI part of the name
        -: 1259:      * @param pszName The base part of the name
        -: 1260:      * @return Returns the complete formatted UName
        -: 1261:      */
        -: 1262:    static XMLCh* makeUName
        -: 1263:    (
        -: 1264:        const   XMLCh* const    pszURI
        -: 1265:        , const XMLCh* const    pszName
        -: 1266:    );
        -: 1267:
        -: 1268:    /**
        -: 1269:      * Internal function to perform token replacement for strings.
        -: 1270:      *
        -: 1271:      * @param errText The text (NULL terminated) where the replacement
        -: 1272:      *        is to be done. The size of this buffer should be
        -: 1273:      *        'maxChars + 1' to account for the final NULL.
        -: 1274:      * @param maxChars The size of the output buffer, i.e. the maximum
        -: 1275:      *         number of characters that it will hold. If the result is
        -: 1276:      *         larger, it will be truncated.
        -: 1277:      * @param text1 Replacement text-one
        -: 1278:      * @param text2 Replacement text-two
        -: 1279:      * @param text3 Replacement text-three
        -: 1280:      * @param text4 Replacement text-four
        -: 1281:      * @param manager The MemoryManager to use to allocate objects
        -: 1282:      * @return Returns the count of characters that are outputted
        -: 1283:      */
        -: 1284:    static XMLSize_t replaceTokens
        -: 1285:    (
        -: 1286:                XMLCh* const    errText
        -: 1287:        , const XMLSize_t       maxChars
        -: 1288:        , const XMLCh* const    text1
        -: 1289:        , const XMLCh* const    text2
        -: 1290:        , const XMLCh* const    text3
        -: 1291:        , const XMLCh* const    text4
        -: 1292:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager
        -: 1293:    );
        -: 1294:
        -: 1295:    /** Converts a string to uppercase
        -: 1296:      * @param toUpperCase The string which needs to be converted to uppercase.
        -: 1297:      *        On return, this buffer also holds the converted uppercase string
        -: 1298:      */
        -: 1299:    static void upperCase(XMLCh* const toUpperCase);
        -: 1300:
        -: 1301:    /** Converts a string to uppercase
        -: 1302:      * The routine only uppercases A to Z (other characters not changed).
        -: 1303:      * @param toUpperCase The string which needs to be converted to uppercase.
        -: 1304:      *        On return, this buffer also holds the converted uppercase string
        -: 1305:      */
        -: 1306:    static void upperCaseASCII(XMLCh* const toUpperCase);
        -: 1307:
        -: 1308:	/** Converts a string to lowercase
        -: 1309:      * @param toLowerCase The string which needs to be converted to lowercase.
        -: 1310:      *        On return, this buffer also holds the converted lowercase string
        -: 1311:      */
        -: 1312:    static void lowerCase(XMLCh* const toLowerCase);
        -: 1313:
        -: 1314:    /** Converts a string to lowercase
        -: 1315:      * The routine only lowercases a to z (other characters not changed).
        -: 1316:      * @param toLowerCase The string which needs to be converted to lowercase.
        -: 1317:      *        On return, this buffer also holds the converted lowercase string
        -: 1318:      */
        -: 1319:    static void lowerCaseASCII(XMLCh* const toLowerCase);
        -: 1320:
        -: 1321:	/** Check if string is WhiteSpace:replace
        -: 1322:      * @param toCheck The string which needs to be checked.
        -: 1323:      */
        -: 1324:    static bool isWSReplaced(const XMLCh* const toCheck);
        -: 1325:
        -: 1326:	/** Check if string is WhiteSpace:collapse
        -: 1327:      * @param toCheck The string which needs to be checked.
        -: 1328:      */
        -: 1329:    static bool isWSCollapsed(const XMLCh* const toCheck);
        -: 1330:
        -: 1331:	/** Replace whitespace
        -: 1332:      * @param toConvert The string which needs to be whitespace replaced.
        -: 1333:      *        On return , this buffer also holds the converted string
        -: 1334:      * @param manager The MemoryManager to use to allocate objects
        -: 1335:      */
        -: 1336:    static void replaceWS(XMLCh* toConvert
        -: 1337:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager);
        -: 1338:
        -: 1339:	/** Collapse whitespace
        -: 1340:      * @param toConvert The string which needs to be whitespace collapsed.
        -: 1341:      *        On return , this buffer also holds the converted string
        -: 1342:      * @param manager The MemoryManager to use to allocate objects
        -: 1343:      */
        -: 1344:    static void collapseWS(XMLCh* toConvert
        -: 1345:        , MemoryManager* const  manager = XMLPlatformUtils::fgMemoryManager);
        -: 1346:
        -: 1347:    /** Remove whitespace
        -: 1348:      * @param toConvert The string which needs to be whitespace removed.
        -: 1349:      *        On return , this buffer also holds the converted string
        -: 1350:      * @param manager The MemoryManager to use to allocate objects
        -: 1351:      */
        -: 1352:    static void removeWS(XMLCh* toConvert
        -: 1353:    , MemoryManager*       const manager = XMLPlatformUtils::fgMemoryManager);
        -: 1354:
        -: 1355:
        -: 1356:    /** Remove character
        -: 1357:      * @param srcString The string
        -: 1358:      * @param toRemove  The character needs to be removed from the string
        -: 1359:      * @param dstBuffer The buffer containing the result
        -: 1360:      */
        -: 1361:    static void removeChar(const XMLCh*     const srcString
        -: 1362:                         , const XMLCh&           toRemove
        -: 1363:                         ,       XMLBuffer&       dstBuffer);
        -: 1364:
        -: 1365:    /**
        -: 1366:     * Fixes a platform dependent absolute path filename to standard URI form.
        -: 1367:     * 1. Windows: fix 'x:' to 'file:///x:' and convert any backslash to forward slash
        -: 1368:     * 2. UNIX: fix '/blah/blahblah' to 'file:///blah/blahblah'
        -: 1369:     * @param str    The string that has the absolute path filename
        -: 1370:     * @param target The target string pre-allocated to store the fixed uri
        -: 1371:     */
        -: 1372:    static void fixURI(const XMLCh* const str, XMLCh* const target);
        -: 1373:
        -: 1374:    //@}
        -: 1375:    /** @name String Memory Management functions */
        -: 1376:    //@{
        -: 1377:    /**
        -: 1378:     * Release the parameter string that was allocated by XMLString::transcode and XMLString::replicate.
        -: 1379:     * The implementation will call MemoryManager::deallocate and then turn the string to a null pointer.
        -: 1380:     *
        -: 1381:     * @param buf  The string to be deleted and become a null pointer.
        -: 1382:     * @param manager The MemoryManager used to allocate the string
        -: 1383:     */
        -: 1384:    static void release
        -: 1385:    (
        -: 1386:        char**  buf
        -: 1387:        ,       MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager
        -: 1388:    );
        -: 1389:
        -: 1390:    /**
        -: 1391:     * Release the parameter string that was allocated by XMLString::transcode and XMLString::replicate.
        -: 1392:     * The implementation will call MemoryManager::deallocate and then turn the string to a null pointer.
        -: 1393:     *
        -: 1394:     * @param buf  The string to be deleted and become a null pointer.
        -: 1395:     * @param manager The MemoryManager used to allocate the string
        -: 1396:     */
        -: 1397:    static void release
        -: 1398:    (
        -: 1399:        XMLCh**  buf
        -: 1400:        ,       MemoryManager* const manager = XMLPlatformUtils::fgMemoryManager
        -: 1401:    );
        -: 1402:    //@}
        -: 1403:
        -: 1404:
        -: 1405:private :
        -: 1406:
        -: 1407:    /** @name Constructors and Destructor */
        -: 1408:    //@{
        -: 1409:    /** Unimplemented default constructor */
        -: 1410:    XMLString();
        -: 1411:    /** Unimplemented destructor */
        -: 1412:    ~XMLString();
        -: 1413:    //@}
        -: 1414:
        -: 1415:
        -: 1416:    /** @name Initialization */
        -: 1417:    //@{
        -: 1418:    /** Init/Term methods called from XMLPlatformUtils class */
        -: 1419:    static void initString(XMLLCPTranscoder* const defToUse,
        -: 1420:                           MemoryManager* const manager);
        -: 1421:    static void termString();
        -: 1422:    //@}
        -: 1423:
        -: 1424:	/**
        -: 1425:	  * Called by regionMatches/regionIMatches to validate that we
        -: 1426:	  * have a valid input
        -: 1427:	  */
        -: 1428:	static bool validateRegion(const XMLCh* const str1, const int offset1,
        -: 1429:						const XMLCh* const str2, const int offset2,
        -: 1430:						const XMLSize_t charCount);
        -: 1431:
        -: 1432:    static MemoryManager* fgMemoryManager;
        -: 1433:
        -: 1434:    friend class XMLPlatformUtils;
        -: 1435:};
        -: 1436:
        -: 1437:
        -: 1438:// ---------------------------------------------------------------------------
        -: 1439://  Inline some methods that are either just passthroughs to other string
        -: 1440://  methods, or which are key for performance.
        -: 1441:// ---------------------------------------------------------------------------
        -: 1442:inline void XMLString::moveChars(       XMLCh* const targetStr
        -: 1443:                                , const XMLCh* const srcStr
        -: 1444:                                , const XMLSize_t    count)
        -: 1445:{
        -: 1446:    memcpy(targetStr, srcStr, count * sizeof(XMLCh));
        -: 1447:}
        -: 1448:
        -: 1449:inline XMLSize_t XMLString::stringLen(const XMLCh* const src)
        -: 1450:{
        -: 1451:    if (src == 0)
        -: 1452:        return 0;
        -: 1453:
        -: 1454:    const XMLCh* pszTmp = src;
        -: 1455:
        -: 1456:    while (*pszTmp++) ;
        -: 1457:
        -: 1458:    return (pszTmp - src - 1);
        -: 1459:}
        -: 1460:
        -: 1461:inline XMLCh* XMLString::replicate(const XMLCh* const toRep,
        -: 1462:                                   MemoryManager* const manager)
        -: 1463:{
        -: 1464:    // If a null string, return a null string!
        -: 1465:    XMLCh* ret = 0;
        -: 1466:    if (toRep)
        -: 1467:    {
        -: 1468:        const XMLSize_t len = stringLen(toRep);
        -: 1469:        ret = (XMLCh*) manager->allocate((len+1) * sizeof(XMLCh)); //new XMLCh[len + 1];
        -: 1470:        memcpy(ret, toRep, (len + 1) * sizeof(XMLCh));
        -: 1471:    }
        -: 1472:    return ret;
        -: 1473:}
        -: 1474:
        -: 1475:inline bool XMLString::startsWith(  const   XMLCh* const    toTest
        -: 1476:                                    , const XMLCh* const    prefix)
        -: 1477:{
        -: 1478:    return (compareNString(toTest, prefix, stringLen(prefix)) == 0);
        -: 1479:}
        -: 1480:
        -: 1481:inline bool XMLString::startsWithI( const   XMLCh* const    toTest
        -: 1482:                                    , const XMLCh* const    prefix)
        -: 1483:{
        -: 1484:    return (compareNIString(toTest, prefix, stringLen(prefix)) == 0);
        -: 1485:}
        -: 1486:
        -: 1487:inline bool XMLString::endsWith(const XMLCh* const toTest,
        -: 1488:                                const XMLCh* const suffix)
        -: 1489:{
        -: 1490:
        -: 1491:    XMLSize_t suffixLen = XMLString::stringLen(suffix);
        -: 1492:
        -: 1493:    return regionMatches(toTest, (int)(XMLString::stringLen(toTest) - suffixLen),
        -: 1494:                         suffix, 0, suffixLen);
        -: 1495:}
        -: 1496:
        -: 1497:inline bool XMLString::validateRegion(const XMLCh* const str1,
        -: 1498:									  const int offset1,
        -: 1499:									  const XMLCh* const str2,
        -: 1500:									  const int offset2,
        -: 1501:									  const XMLSize_t charCount)
        -: 1502:{
        -: 1503:
        -: 1504:	if (offset1 < 0 || offset2 < 0 ||
        -: 1505:		(offset1 + charCount) > XMLString::stringLen(str1) ||
        -: 1506:		(offset2 + charCount) > XMLString::stringLen(str2) )
        -: 1507:		return false;
        -: 1508:
        -: 1509:	return true;
        -: 1510:}
        -: 1511:
function _ZN11xercesc_3_19XMLString6equalsEPKtS2_ called 15 returned 100% blocks executed 53%
       15: 1512:inline bool XMLString::equals(   const XMLCh* str1
        -: 1513:                               , const XMLCh* str2)
        -: 1514:{
       15: 1515:    if (str1 == str2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1516:        return true;
        -: 1517:
       15: 1518:    if (str1 == 0 || str2 == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1519:        return ((!str1 || !*str1) && (!str2 || !*str2));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1520:
       70: 1521:    while (*str1)
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
       49: 1522:        if(*str1++ != *str2++)  // they are different (or str2 is shorter and we hit the NULL)
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        9: 1523:            return false;
        -: 1524:
        -: 1525:    // either both ended (and *str2 is 0 too), or str2 is longer
        6: 1526:    return (*str2==0);
        -: 1527:}
        -: 1528:
        -: 1529:inline bool XMLString::equalsN(const XMLCh* str1,
        -: 1530:                               const XMLCh* str2,
        -: 1531:                               XMLSize_t n)
        -: 1532:{
        -: 1533:    if (str1 == str2 || n == 0)
        -: 1534:      return true;
        -: 1535:
        -: 1536:    if (str1 == 0 || str2 == 0)
        -: 1537:        return ((!str1 || !*str1) && (!str2 || !*str2));
        -: 1538:
        -: 1539:    for (; n != 0 && *str1 && *str2; --n, ++str1, ++str2)
        -: 1540:      if(*str1 != *str2)
        -: 1541:        break;
        -: 1542:
        -: 1543:    return n == 0 || *str1 == *str2; // either equal or both ended premat.
        -: 1544:}
        -: 1545:
        -: 1546:inline bool XMLString::equals(   const char* str1
        -: 1547:                               , const char* str2)
        -: 1548:{
        -: 1549:    if (str1 == str2)
        -: 1550:        return true;
        -: 1551:
        -: 1552:    if (str1 == 0 || str2 == 0)
        -: 1553:        return ((!str1 || !*str1) && (!str2 || !*str2));
        -: 1554:
        -: 1555:    while (*str1)
        -: 1556:        if(*str1++ != *str2++)  // they are different (or str2 is shorter and we hit the NULL)
        -: 1557:            return false;
        -: 1558:
        -: 1559:    // either both ended (and *str2 is 0 too), or str2 is longer
        -: 1560:    return (*str2==0);
        -: 1561:}
        -: 1562:
        -: 1563:inline bool XMLString::equalsN(const char* str1,
        -: 1564:                               const char* str2,
        -: 1565:                               XMLSize_t n)
        -: 1566:{
        -: 1567:    if (str1 == str2 || n == 0)
        -: 1568:      return true;
        -: 1569:
        -: 1570:    if (str1 == 0 || str2 == 0)
        -: 1571:        return ((!str1 || !*str1) && (!str2 || !*str2));
        -: 1572:
        -: 1573:    for (; n != 0 && *str1 && *str2; --n, ++str1, ++str2)
        -: 1574:      if(*str1 != *str2)
        -: 1575:        break;
        -: 1576:
        -: 1577:    return n == 0 || *str1 == *str2; // either equal or both ended premat.
        -: 1578:}
        -: 1579:
        -: 1580:inline int XMLString::lastIndexOf(const XMLCh* const toSearch, const XMLCh ch)
        -: 1581:{
        -: 1582:    return XMLString::lastIndexOf(ch, toSearch, stringLen(toSearch));
        -: 1583:}
        -: 1584:
        -: 1585:inline XMLSize_t XMLString::hash(const   XMLCh* const   tohash
        -: 1586:                                , const XMLSize_t          hashModulus)
        -: 1587:{
        -: 1588:    if (tohash == 0 || *tohash == 0)
        -: 1589:        return 0;
        -: 1590:
        -: 1591:    const XMLCh* curCh = tohash;
        -: 1592:    XMLSize_t hashVal = (XMLSize_t)(*curCh++);
        -: 1593:
        -: 1594:    while (*curCh)
        -: 1595:        hashVal = (hashVal * 38) + (hashVal >> 24) + (XMLSize_t)(*curCh++);
        -: 1596:
        -: 1597:    // Divide by modulus
        -: 1598:    return hashVal % hashModulus;
        -: 1599:}
        -: 1600:
        -: 1601:inline XMLSize_t XMLString::hashN(const   XMLCh* const   tohash
        -: 1602:                                  , const XMLSize_t       n
        -: 1603:                                  , const XMLSize_t       hashModulus)
        -: 1604:{
        -: 1605:  if (tohash == 0 || n == 0)
        -: 1606:    return 0;
        -: 1607:
        -: 1608:  const XMLCh* curCh = tohash;
        -: 1609:  XMLSize_t hashVal = (XMLSize_t)(*curCh++);
        -: 1610:
        -: 1611:  for(XMLSize_t i=0;i<n;i++)
        -: 1612:    hashVal = (hashVal * 38) + (hashVal >> 24) + (XMLSize_t)(*curCh++);
        -: 1613:
        -: 1614:  // Divide by modulus
        -: 1615:  return hashVal % hashModulus;
        -: 1616:}
        -: 1617:
        -: 1618:XERCES_CPP_NAMESPACE_END
        -: 1619:
        -: 1620:#endif
